# 英単語学習Webアプリ 実装計画書

## 1. 開発環境・ツール選定

### パッケージマネージャー

#### 選択肢と詳細比較

##### 1. npm (Node Package Manager)
**特徴:**
- Node.js標準、最も広く使われている
- package-lock.jsonでバージョン固定
- npm workspacesでmonorepo対応

**メリット:**
- 学習コストが最も低い
- 情報・サンプルが豊富
- CI/CDの設定が簡単

**デメリット:**
- 他と比べてインストール速度が遅い
- ディスク容量を多く使用

##### 2. Yarn (v1 Classic / v3 Berry)
**特徴:**
- Facebook(Meta)が開発
- yarn.lockでバージョン固定
- Workspaces機能が強力

**メリット:**
- npmより高速なインストール
- 優秀なキャッシュ機能
- Zero-installs対応（v3）

**デメリット:**
- v1とv3で大きく仕様が異なる
- v3は学習コストが高め

##### 3. pnpm (performant npm)
**特徴:**
- Hard linkでディスク容量を大幅節約
- 厳密な依存関係管理（phantom dependency防止）
- pnpm-lock.yamlでバージョン固定

**メリット:**
- 最も高速なインストール
- ディスク容量を最も節約（90%削減も可能）
- 依存関係の問題を早期発見

**デメリット:**
- まれに互換性問題
- 学習コストが少し高い

#### 速度・容量比較（目安）
| | インストール速度 | ディスク使用量 | 学習コスト |
|---|---|---|---|
| npm | 基準 | 基準 | ★☆☆ |
| yarn | 1.5-2x速い | 0.8-0.9x | ★★☆ |
| pnpm | 2-3x速い | 0.1-0.3x | ★★☆ |

#### 決定事項
- **パッケージマネージャー**: pnpm

#### 選定理由
- 高速インストールで開発効率向上
- ディスク容量節約（複数プロジェクト開発時に効果的）
- 厳密な依存管理で潜在バグの早期発見

### リンター・フォーマッター設定

#### 選択肢と特徴

##### 1. ESLint + Prettier (標準構成)
**ESLint**: コード品質・潜在バグ検出
**Prettier**: コード整形・スタイル統一

**メリット:**
- Next.js標準サポート
- TypeScript対応
- 豊富なプラグイン

**デメリット:**
- 設定が複雑になりがち
- ESLintとPrettierの競合設定に注意が必要

##### 2. Biome (新世代ツール)
**特徴:**
- ESLint + Prettier の機能を1ツールで提供
- Rust製で超高速
- 設定がシンプル

**メリット:**
- 圧倒的な高速性（10-100倍速い）
- 設定ファイルが1つで済む
- メモリ使用量が少ない

**デメリット:**
- まだ比較的新しい（安定性）
- プラグインエコシステムが限定的

#### 決定事項
- **リンター・フォーマッター**: Biome

#### 選定理由
- 圧倒的な高速性（pnpmと同じく効率性重視）
- 設定がシンプル（biome.jsonのみ）
- 依存ライブラリが少なく軽量
- ESLint + Prettier の機能を1ツールで提供

### TypeScript設定

#### 選択肢と特徴

##### 1. Next.js デフォルト設定
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "strict": true,
    "jsx": "preserve"
  }
}
```

**メリット:**
- Next.js最適化済み
- 追加設定不要

**デメリット:**
- 一部の厳密チェックが甘い

##### 2. 厳密設定 (推奨)
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "ES2022"],
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

**メリット:**
- より多くのバグを事前発見
- 型安全性が高い
- モダンJS機能を活用

**デメリット:**
- 学習コストが少し高い
- 初期は型エラーが多め

#### 決定事項
- **TypeScript設定**: 厳密設定

#### 選定理由
- 学習データの整合性確保が重要
- 実行時エラーの事前防止
- 長期的な保守性向上
- モダンJS機能を活用した開発

### 開発サーバー設定

#### 選択肢と特徴

##### 1. Next.js標準開発サーバー
```bash
pnpm dev
```

**メリット:**
- 設定不要、即座に開始
- Hot Reload標準対応
- Next.js最適化済み

**デメリット:**
- カスタマイズ性が限定的

##### 2. Turbopack (実験的)
```bash
pnpm dev --turbo
```

**メリット:**
- Rust製で高速コンパイル
- 大規模プロジェクトで効果大
- Next.js 13+で標準サポート

**デメリット:**
- まだ実験的機能（beta）
- 一部プラグインが非対応の可能性

#### 決定事項
- **開発サーバー**: Next.js標準開発サーバー

#### 選定理由
- 小規模プロジェクトで十分な性能
- 安定性重視
- 設定の複雑化を避ける

## 2. 実装の優先順位・段階

### MVP (最小機能) の範囲定義

#### フェーズ1: 基本学習機能 (MVP)
**目標**: 最低限の学習体験を提供
- ✅ 基本的な出題・回答機能
- ✅ 簡易認証（名前入力のみ）
- ✅ 10問1セッションの学習フロー
- ✅ 正誤判定と結果表示

**除外項目（後回し）**:
- LINE Login認証
- CSVインポート機能
- 詳細統計画面
- 出題アルゴリズム（ランダム出題のみ）

#### フェーズ2: 学習最適化
**目標**: 効率的な学習体験
- ✅ 出題アルゴリズム実装 (2:4:4比率)
- ✅ 学習履歴の詳細管理
- ✅ 進捗統計表示

#### フェーズ3: 運用機能
**目標**: 本格運用対応
- ✅ LINE Login認証
- ✅ CSVインポート機能
- ✅ 管理者機能

### 実装順序 (フェーズ1)

#### 優先度A: 最優先
1. **プロジェクト初期設定** (Next.js + 依存関係)
2. **データベース設計・セットアップ** (Prisma + Neon)
3. **基本UI構成** (レイアウト + ルーティング)

#### 優先度B: 核心機能
4. **簡易認証機能** (名前入力 + ローカルストレージ)
5. **単語データ準備** (テスト用データ投入)
6. **出題・回答機能** (ランダム出題)
7. **結果表示機能**

#### 優先度C: 完成度向上
8. **セッション管理**
9. **基本統計表示**
10. **レスポンシブ対応**

#### 決定事項
実装順序に同意。MVP重視で段階的開発を進める。

## 3. フォルダ構成・命名規則

### Next.js App Router構成

#### 推奨フォルダ構造
```
word-practice/
├── src/
│   ├── app/                    # App Router (ページ・レイアウト)
│   │   ├── (auth)/            # 認証関連のルートグループ
│   │   ├── learn/             # 学習ページ
│   │   ├── stats/             # 統計ページ
│   │   ├── api/               # API Routes
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/            # 再利用コンポーネント
│   │   ├── ui/               # 基本UIコンポーネント
│   │   ├── features/         # 機能別コンポーネント
│   │   └── layout/           # レイアウト関連
│   ├── lib/                  # ユーティリティ・設定
│   │   ├── db/              # データベース関連
│   │   ├── auth/            # 認証関連
│   │   └── utils/           # 汎用ユーティリティ
│   ├── types/               # TypeScript型定義
│   └── hooks/               # カスタムReactフック
├── prisma/                  # Prisma設定・スキーマ
├── docs/                    # ドキュメント
├── public/                  # 静的ファイル
└── 設定ファイル各種
```

#### 決定事項
上記のフォルダ構成で進める。

### 命名規則

#### ファイル・フォルダ命名
- **フォルダ名**: kebab-case (`word-list`, `user-stats`)
- **コンポーネントファイル**: PascalCase (`WordCard.tsx`, `SessionResult.tsx`)
- **ユーティリティファイル**: camelCase (`wordUtils.ts`, `dbConnection.ts`)
- **ページファイル**: Next.js規則 (`page.tsx`, `layout.tsx`)

#### 変数・関数命名
- **変数・関数**: camelCase (`wordList`, `getUserStats`)
- **定数**: UPPER_SNAKE_CASE (`DEFAULT_SESSION_SIZE`, `API_ENDPOINTS`)
- **型・インターフェース**: PascalCase (`Word`, `UserSession`, `ApiResponse`)
- **コンポーネントProps**: PascalCaseで型名 + Props (`WordCardProps`)

#### データベース命名
- **テーブル名**: snake_case (単数形) (`user`, `word`, `learning_history`)
- **カラム名**: snake_case (`japanese_meaning`, `created_at`)
- **インデックス名**: `idx_テーブル名_カラム名` (`idx_user_line_id`)

## 4. UI/スタイリング方針

### スタイリング手法の選択肢

#### 1. Tailwind CSS (推奨)
**特徴:**
- ユーティリティファースト
- 高速プロトタイピング
- レスポンシブ対応が簡単

**メリット:**
- 設定済みデザインシステム
- バンドルサイズ最適化
- モバイルファースト設計

**デメリット:**
- 初期学習コストあり
- HTMLが長くなりがち

#### 2. CSS Modules
**特徴:**
- スコープ付きCSS
- 標準的なCSS記法

**メリット:**
- CSS知識をそのまま活用
- スタイルの局所化

**デメリット:**
- 設定とファイル管理が複雑
- レスポンシブ対応が手間

#### 3. styled-components (CSS-in-JS)
**特徴:**
- JSでスタイル記述
- 動的スタイリング

**メリット:**
- TypeScriptとの親和性
- 条件分岐スタイルが簡単

**デメリット:**
- ランタイムオーバーヘッド
- Next.js SSRで設定が必要

#### 決定事項
- **スタイリング**: Tailwind CSS

#### 選定理由
- モバイルファースト設計で要件に最適
- レスポンシブ対応が簡単
- 高速プロトタイピングでMVP開発に適している
- バンドルサイズ最適化でパフォーマンス重視

### コンポーネントライブラリ

#### 選択肢
1. **shadcn/ui** (推奨)
   - Tailwind CSS ベース
   - copy&paste式で軽量
   - TypeScript対応

2. **Headless UI**
   - アクセシビリティ重視
   - 低レベルコンポーネント

3. **自作コンポーネントのみ**
   - 最軽量
   - 学習コストあり

#### 決定事項
- **コンポーネントライブラリ**: shadcn/ui

#### 選定理由
- Tailwind CSS完全対応
- copy&paste式で必要な分のみ導入可能
- TypeScript対応でtsx開発に適している
- 高品質なアクセシビリティ対応

#### 導入予定コンポーネント (MVP向け)
- Button
- Input
- Card
- Badge (正解・不正解表示)
- Progress (セッション進捗)

---

# 実装計画 完了

## 決定事項まとめ

### 開発環境
- **パッケージマネージャー**: pnpm
- **リンター・フォーマッター**: Biome
- **TypeScript**: 厳密設定
- **開発サーバー**: Next.js標準

### UI/UX
- **スタイリング**: Tailwind CSS
- **コンポーネント**: shadcn/ui (必要分のみ)
- **レスポンシブ**: モバイルファースト

### 実装戦略
- **MVP重視**: 基本学習機能から段階的開発
- **フェーズ分割**: 基本機能 → 学習最適化 → 運用機能

実装開始の準備が整いました！